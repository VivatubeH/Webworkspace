210. Introduction to Lambda Expression

강사: 새로운 주제를 시작합시다.

이번 주제는 람다 표현식입니다.

람다 표현식은 익명 메서드나 이름 없는 메서드 또는 함수 정의에 사용됩니다.

람다 표현식은 인터페이스를 통해 정의됩니다.

그래서 먼저 인터페이스를 정의하고

우리가 이미 배운 주제를 설명하겠습니다.

그런 다음 람다 표현식이 무엇인지 보여드리겠습니다.

그래서 람다 표현식의 개념을 편안하게 이해할 수 있게 할 것입니다.

먼저 하나의 인터페이스를 정의해 봅시다.

MyLambda라는 인터페이스가 있습니다.

이 인터페이스는 단 하나의 메서드를 가지고 있습니다.

하나의 메서드, 그것은 display입니다.

그리고 인터페이스 내의 모든 메서드는 기본적으로 public과 abstract라는 것을 잘 알고 있습니다.

그래서 이것은 public이면서 abstract입니다.

public 키워드를 썼지만,

제거해도 기본적으로 public입니다.

이제 여기서 중요한 것을 배울 것입니다.

만약 인터페이스가 단 하나의 추상 메서드만 가지고 있으면,

그것은 기능적 인터페이스라고 불립니다.

기능적 인터페이스라고 불립니다.

심지어 나는 FunctionalInterface라는 어노테이션을

여기 위에 사용할 수 있습니다.

이 어노테이션을 사용하면 에러가 발생하지 않습니다.

즉, 완벽한 기능적 인터페이스입니다.

만약 여기에 또 다른 메서드를 작성하면,

하나의 메서드를 더 작성했습니다.

그래서 에러가 발생합니다.

왜냐하면 이것은 기능적 인터페이스가 아니기 때문입니다.

기능적 인터페이스는 단 하나의 메서드만 가져야 합니다.

이것이 우리가 배운 첫 번째 것입니다.

이것은 람다 표현식을 이해하는 데 필수적입니다.

좋습니다.

인터페이스가 있을 때, 우리는 인터페이스를 구현하고 클래스를 정의할 수 있습니다.

그래서 이 다음에, 나는 이 인터페이스를 구현하고 이 메서드를 오버라이드하는

하나의 클래스를 작성할 것입니다.

그래서 클래스를 작성하고 나서 설명을 계속하겠습니다.

My라는 클래스를 작성했습니다.

이 클래스는 MyLambda라는 인터페이스를 구현하고,

display 메서드를 오버라이드합니다.

이 메서드는 "Hello World"라는 메시지를 출력합니다.

이제 MyLambda라는 인터페이스가 있고, 하나의 메서드를 가지고 있습니다.

이것은 기능적 인터페이스입니다.

그리고 이 인터페이스를 구현하는 클래스가 있습니다.

그래서 이 메서드를 오버라이드합니다.

메인 메서드 내에서 이 클래스의 객체를 생성하고 이 메서드를 호출할 수 있습니다.

그래서 빠르게 해보겠습니다.

My 클래스의 객체를 생성하고 display 메서드를 호출할 수 있습니다.

그래서 이것은 이미 알고 있는 인터페이스와

그 구현 방법에 대한 것입니다.

이제 다음 단계로 넘어갑시다, 보세요.

My 클래스의 참조를 사용하는 대신,

람다, 즉 MyLambda의 참조로 변경할 수 있습니다. 맞죠?

이것은 작동합니다. 왜냐하면 MyLambda는 이 클래스 My에 의해 구현되었기 때문에,

My 클래스의 객체도 MyLambda의 참조를 가질 수 있습니다.

네, MyLambda 참조는 이 객체를 가질 수 있습니다.

이것은 작동합니다. 보세요, 실행하지 않았지만, 실행하면

"Hello World" 메시지를 출력할 것입니다.

이것으로 끝입니다.

이제 다음 단계로 넘어갑시다.

보세요, 별도의 클래스를 작성하는 대신,

내부 클래스를 작성할 수 있습니다. 맞죠? 이것에 대해 알고 있습니다.

우리는 내부 클래스에 대해서도 배웠으니까요.

그래서 이것에 대해 알고 있습니다.

이제 여기에는 My라는 클래스가 없기 때문에,

여기서 에러가 발생합니다.

여기서 클래스를 정의할 수 있나요?

네, 익명 내부 클래스를 정의할 수 있습니다.

그래서 나는 어떤 클래스를 사용하지 않을 것입니다.

나는 이 MyLambda 인터페이스를 사용할 것입니다. 좋습니까?

그리고 이 MyLambda 인터페이스에 대해,

인터페이스의 객체를 생성하는 것처럼,

그 안에 메서드를 작성할 것입니다. public void display,

그 안에서 "Hello World"라는 메시지를 출력할 것입니다.

이제 여기서 MyLambda 인터페이스의 객체를 생성하고,

그 인터페이스의 메서드를 오버라이드합니다.

이것은 익명 내부 클래스입니다. 맞죠?

그래서 별도의 클래스를 작성하는 대신,

내부 클래스로 만들 수도 있었습니다.

하지만 나는 익명 내부 클래스를 작성하고 있습니다.

이제 우리는 람다 표현식에 아주 가까워졌습니다.

이제 아주 주의 깊게 보세요. 이것들은 우리가 지금까지 배운 것입니다. 맞죠?

이제 람다 표현식을 이해하는 것이 매우 쉬워질 것입니다.

이걸 보세요.

제가 display라는 메서드를 작성했는데, 모든 것이 다 있습니다.

이제, 이를 람다 표현식으로 변환해보겠습니다.

잘 보세요.

이 메서드의 이름을 줄 필요가 없습니다.

이것을 제거하세요, 괄호만 있으면 됩니다.

그리고 인터페이스명이나 클래스명도 줄 필요 없습니다, 보세요,

이것이 인터페이스명이고 이것이 여는 괄호입니다,

여는 괄호까지, 여기까지 이것을 제거하세요.

그래서 이제 남은 것은 메서드 내부뿐이고

메서드 이름은 사라졌습니다.

이것도 제거하세요.

보세요, 인터페이스명도 사라졌고 메서드 이름도

사라졌습니다, 빈 괄호만 있습니다.

그래서 빈 괄호 뒤에 이 화살표를 주면 됩니다,

이 연산자.

그리고 그 후에 세미콜론을 주면 됩니다.

그게 전부입니다, 이것이 람다 표현식입니다.

다시 한번 보여드릴게요.

보세요, 메서드 이름을 제거하세요, public void,

메서드 이름이 필요 없습니다, 메서드 이름이 필요 없습니다.

그리고 이 인터페이스명도 필요 없습니다

익명 클래스와 함께 있는 괄호도 필요 없습니다.

닫는 괄호도 제거하세요.

그리고 여기 화살표를 주면 됩니다, 알겠죠?

그 다음, 이것이 세미콜론입니다,

줄이 여기서 끝나기 때문에 세미콜론을 줍니다.

그래서 이것이 람다 표현식이 되었습니다.

그래서 이것이 이 display 메서드를 가리키는 것입니다.

어떻게 이것이 display 메서드인지 알 수 있나요?

MyLambda를 참조하기 때문에, MyLambda를 참조하기 때문에,

MyLambda 안에 있는 메서드를 오버라이드하는 것임을 이해할 수 있습니다,

그리고 오직 하나의 메서드만 있기에 혼동의 여지가 없습니다.

그리고 그 메서드는 인수를 받지 않기 때문에

이 괄호가 비어 있습니다.

그래서 이 괄호는 이 display 메서드를 나타냅니다.

display 메서드는 이 메서드 본문을 의미합니다.

심지어 한 줄로 쓸 수도 있습니다.

보세요, 이제 모든 것이 한 줄에 있습니다.

저는 단지 메서드를 작성했을 뿐입니다,

객체를 생성하지 않았습니다.

그래서 메서드 자체가 객체가 됩니다.

익명 클래스가 아니라, 이것은 익명 메서드입니다,

그리고 그 메서드는 객체로서 동작합니다.

실행되는지 확인해봅시다.

네, Hello World.

보세요, 참조를 통해 display 메서드를 호출하고 있습니다.

display 메서드의 정의는 어디에 있나요?

이것이 display 메서드의 정의입니다.

이것이 정의인데, Hello World를 출력합니다,

그래서 m.display를 호출하면 이 메서드가 호출됩니다

왜냐하면 정의가 존재하기 때문입니다.

이게 전부입니다.

기능적 인터페이스를 쉽게 구현하기 위해,

자바는 이 개념을 도입했습니다,

그리고 이 람다 표현식은 매우 강력하고

매우 유용합니다, 그리고 저는 이것들이

프로그래머들에게 매우 편리하고

쉽다고 말하고 싶습니다.

이런 기능을 구현하기 위해 길게 코드를 작성할 필요가 없습니다.

보세요, 첫 번째 예제에서는 클래스를 작성했으며,

인터페이스를 구현하고 메서드를 오버라이드하는 기본 방법입니다.

두 번째로 보여드린 것은 익명 클래스입니다,

이것은 조금 더 쉽습니다,

코드를 빠르게 작성할 수 있습니다.

이제, 아주 작은 작업을 해야 한다면,

클래스를 작성할 필요가 있을까요?

메서드처럼 쓸 수는 없을까요?

저는 단지 Hello World를 출력해야 합니다.

그러면 왜 그렇게 많은 코드를 작성해야 할까요?

그래서 람다 표현식은

프로그래머들이 기능적 인터페이스를 오버라이드할 때

삶을 쉽게 만들어줍니다, 그래서 이것이 전부입니다,

이것이 람다 표현식의 소개입니다.

다음 비디오에서는 다양한 유형의

람다 표현식이나 람다 표현식을 사용하여 할 수 있는 모든 것을 보여드리겠습니다.

이 비디오의 내용은 여기까지입니다, 이 프로그램을 직접 연습해보세요,

알겠죠, 놓치지 마세요.
		
211. Parameters in Lambda Expression

강사: 이 비디오에서는

람다 표현식이 어떻게 매개변수를 받을 수 있는지

그리고 람다 표현식이 결과를 반환하는 방법에 대해 배울 것입니다.

지금 보고 있는 예제는

이전 비디오에서 이미 다루었습니다.

이전 비디오를 보지 않았다면

그 비디오를 꼭 시청하세요.

왜냐하면 이 예제는 그 예제의 연속이기 때문입니다.

그래서 다시 한번,

여기서 예제에 대해 간략히 설명하겠습니다.

보세요, 이것은 인터페이스입니다.

이것은 함수형 인터페이스입니다.

이미 여기 주석을 작성해 두었습니다.

함수형 인터페이스란

단일 메서드를 가진 인터페이스를 의미합니다.

그리고 여기서 인터페이스의 참조를 사용하고 있습니다.

그것이 바로 나의 람다입니다.

이 메서드는 람다 표현식을 사용하여 재정의되었습니다.

이것은 람다 표현식으로 정의되었습니다.

그래서 이 기호는 람다 표현식을 나타냅니다, 알겠죠?

이제 이 메서드가 할 일은 "Hello World"를 출력하는 것입니다.

이제 다음으로 넘어가겠습니다.

이 메서드가 매개변수를 받을 때

람다 표현식을 어떻게 정의하는지 살펴보겠습니다.

그래서 나는 문자열 str이라는 매개변수를 받을 것입니다.

그러면 여기서 표현식은 몇 가지 매개변수를 받아야 합니다.

그래서 나는 s라는 매개변수를 받을 것입니다.

s는 매개변수가 있다는 것을 의미합니다.

매개변수가 있다는 것을 의미합니다.

그래서 매개변수 m을 s로 받을 때

이 매개변수의 타입은 무엇일까요?

자동으로 문자열이 됩니다.

컴파일러는 이것이 문자열이라는 것을 어떻게 알까요?

보세요, 나는 인터페이스 람다의 참조를 사용하고 있습니다.

이것은 단일 메서드를 가지고 있으며

그 메서드는 하나의 매개변수를 받고 있습니다. 그것이 문자열입니다.

그래서 당연히 이 s는 문자열입니다.

그래서 여기서 문자열 s를 작성할 필요가 없습니다.

이것을 작성할 필요가 없습니다.

그래서 자동으로 s는 문자열을 의미합니다.

그러면 여기서 코드를 변경하겠습니다.

이것은 문자열을 받고 문자열을 출력할 것입니다, 알겠죠?

그래서 문자열 str을 출력하겠습니다.

끝입니다. 죄송합니다, str이 아니라 s입니다.

그런 다음 여기서 이 인터페이스의 display 메서드를 호출할 때

이 표현식이 호출될 것입니다, 그렇죠?

그래서 그것은 s를 출력할 것입니다.

그래서 나는 문자열을 전달해야 합니다. 왜냐하면 그것은 문자열을 받고 있기 때문입니다.

여기서 "Hello World"를 전달하겠습니다.

그래서 이 "Hello World"는 문자열로 전달되고

여기서 출력됩니다.

실행해 보겠습니다.

"Hello World"가 출력되었습니다.

문자열을 변경할 수 있습니다.

여기서 무엇이든 작성할 수 있습니다.

예를 들어 "Java Programming"이라는 문자열을 작성하겠습니다.

철자를 신경 쓰지 마세요.

아마도 잘못 입력되었을 것입니다.

그래서 "Java Programming"이 여기 출력되었습니다, 알겠죠?

그래서 어떤 문자열을 전달하든 그것을 받습니다.

이것이 단일 매개변수입니다.

이제 다른 예제를 살펴보겠습니다.

메서드가 여러 매개변수를 받을 수 있을까요?

메서드도 여러 매개변수를 받을 수 있습니다.

그래서 이 메서드 이름을 변경하겠습니다.

그리고 메서드 이름을 add로 지정하겠습니다. 정수 x와 y를 추가합니다.

그래서 이 메서드 이름은 두 정수를 더하는 것입니다, 알겠죠?

두 정수를 더하는 것입니다.

그러면 이 람다 표현식을 변경해야 합니다.

이것을 삭제하고 다시 작성하겠습니다.

그리고 이 메서드 호출도 다시 호출하겠습니다.

그래서 이것을 제거하겠습니다.

새로 작업하겠습니다.

add라는 메서드를 가지고 있습니다.

람다 표현식을 작성해 보겠습니다. a와 b입니다.

두 개의 매개변수를 받고, 그런 다음 람다 표현식.

그럼 무엇을 해야 하나요?

a와 b의 합을 반환해야 합니다.

그런 다음 괄호를 닫고, 그런 다음 세미콜론.

그게 다입니다.

그래서 두 값을 더하고 결과를 반환할 것입니다.

그래서 직접적으로 반환문을 사용했습니다.

다음으로, 이제 이것을 호출하겠습니다.

그래서 호출하려면,

이것의 결과를 직접 출력하겠습니다.

System.out.println(m.add(20, 30))을 작성했습니다.

그래서 이것은 20과 30을 a와 b로 보내고

a와 b가 더해져서 반환됩니다.

그래서 결과가 여기 출력될 것입니다.

이것을 확인해 보겠습니다.

네, 결과는 50입니다.

그래서 이 람다 표현식이

add 메서드를 호출할 때 호출된다는 것을 의미합니다, 그렇죠?

결과를 변수에 저장하고 싶다면,

저장할 수도 있습니다.

여기서 잘라내겠습니다.

그리고 결과를 위한 변수를 r로 가져갈 겁니다, 알겠죠?

그래서 결과는 r로 가져가고 r를 여기에 출력합니다.

그래서 반환 값은 변수 r에 저장됩니다.

그래서 두 개의 매개변수를 받을 경우 이렇게 할 수 있습니다.

이제 여기서 한 가지 더 보여드리겠습니다.

이 반환문을 제거하겠습니다.

반환문을 제거하겠습니다.

그냥 a 더하기 b입니다.

네, 이것도 맞습니다.

반환이라고 말할 필요가 없습니다.

반환이라고 말할 필요가 없습니다.

자동으로 반환될 것입니다.

자동으로 반환될 것입니다.

그래서 키워드 return을 사용할 필요도 없습니다.

a 더하기 b가 더해지고,

당연히 a 더하기 b로 무엇을 해야 합니까?

반환해야 합니다.

왜 반환해야 합니까?

왜냐하면 반환 타입이 정수이기 때문입니다.

네, 그래서 이것도 허용됩니다.

이것도 가능합니다.

여기서 흥미로운 점은

a 더하기 b는 결국 표현식이라는 것입니다, 그렇죠?

그래서 이름이 람다 표현식이라고 붙여진 것입니다.

표현식을 메서드처럼 쓸 수 있습니다.

그래서 람다 표현식이라는 이름이 붙여진 것입니다.

그래서 제가 람다 표현식이

어떻게 매개변수를 받을 수 있는지 보여드렸습니다.

여러 매개변수도 보낼 수 있으며,

그 매개변수를 여기에 작성하고

어떻게 반환하는지 보여드렸습니다.

그리고 키워드 return을 사용하지 않고도 값을 반환할 수 있습니다.

그래서 우리는 매개변수를 받는 람다 표현식과

결과를 반환하는 방법을 보았습니다.

네, 여기까지입니다.

짧은 비디오입니다.

하지만 매개변수와 반환 타입이라는 단일 주제를 다루고 있습니다.

그래서 어떤 메서드든 매개변수와 반환 타입에 대해 배우기 때문에

그 부분을 보여드렸습니다.

람다 표현식에 대해 더 많이 배울 것입니다.

다음 비디오에서 더 배우겠습니다,

그래서 이 부분을 연습해보세요.

직접 코드를 입력하고 확인해보세요.

이번 비디오에서는 여기까지입니다.

212. Capture in Lambda Expression

강사: 이번 비디오에서는 람다 표현식에 대해 몇 가지 더 배워보겠습니다.

예를 들어 람다 표현식이 로컬 변수를 가질 수 있는가? 로컬 변수나 인스턴스 변수를 접근할 수 있는가? 즉, 인스턴스 변수를 캡처할 수 있는가? 우리는 이것에 대해 배울 것이고, 람다 표현식을 매개변수로 전달할 수 있는지도 배울 것입니다. 이 모든 것을 살펴보겠습니다. 알겠죠?

설명을 위해 이전 비디오에서 사용한 동일한 예제를 사용하겠습니다. 함수형 인터페이스를 가지고 있으며, display라는 메서드를 가진 인터페이스가 있습니다. 그런 다음 메인 메서드를 사용하는 대신 다른 메서드가 있는 다른 클래스를 작성했습니다, 그것이 method1입니다. 알겠죠? 메인은 정적 메서드이기 때문에 비정적 메서드를 사용해서 보여주고 싶어서 별도의 클래스 demo를 작성하고, 메인 메서드 안에서 demo 객체를 생성하고 그 객체의 method1을 호출하고 있습니다. 지금 보시는 것이 프로그램의 구조입니다.

이제 이 인터페이스에 대한 람다 표현식을 작성해보겠습니다. 여기 method1 안에서 람다 표현식을 작성할 것입니다. 알겠죠? 람다 표현식을 작성했고, "hi"를 출력하는 단일 문장입니다. 그리고 이 문장을 괄호로 감쌀 수도 있습니다. 알겠죠? 단일 문장일 경우 괄호 없이도 작성할 수 있습니다.

이제 다음을 보겠습니다. 람다 표현식 안에 여러 문장을 가질 수 있을까요? 네, 원하는 만큼의 문장을 가질 수 있습니다. "bye"를 출력하는 문장을 하나 더 추가하겠습니다. 네, NetBeans가 오류를 표시하지 않네요. 이는 허용된다는 의미입니다, 오류가 없습니다.

이제 이 람다 표현식 안에서 변수를 선언할 수 있을까요? 어떤 변수든 선언할 수 있습니다. 변수를 출력할 수 있을까요? 네, 람다 표현식은 로컬 변수도 가질 수 있으며, 그 로컬 변수를 사용할 수 있습니다. 이제 이 count의 값을 변경하는 것이 허용될까요? 확인해보겠습니다.

네, 이는 메서드의 로컬 변수와 같습니다. 우리가 이 메서드를 람다 표현식으로 재정의하고 있기 때문입니다. 이제 다음을 보겠습니다. count를 제거하는 것이 좋겠습니다. count를 제거하겠습니다.

이제 method1 안에 변수를 하나 선언하겠습니다. count를 0으로 할당하겠습니다. 이제 이 부분을 아주 주의 깊게 보십시오. method1 안에서 count++을 작성하겠습니다. 이 순간 count++을 작성했을 때 오류가 발생합니다. 오류 메시지를 읽어보면 람다 표현식에서 참조된 로컬 변수는 final이거나 사실상 final이어야 한다고 합니다. 이는 무엇을 의미할까요? 람다 표현식은 자신의 컨텍스트 외부에 있는 변수만 접근할 수 있습니다. 이는 람다 표현식의 일부가 아닌 변수입니다. 람다 표현식은 final이거나 사실상 final인 변수만 접근할 수 있습니다. 사실상 final이라는 것은 무엇을 의미할까요? 내가 이 변수를 변경하지 않는 한, 이는 final입니다. 하지만 count++을 변경하고 있기 때문에 final이 아닙니다. 이 부분을 제거하면 어떻게 될까요? 이를 수정하지 않으면 이는 final입니다. 초기 값이 무엇이든 허용됩니다. 이 값을 람다 표현식 안에서 수정할 수 있을까요? 확인해보겠습니다.

아니요, 수정할 수 없습니다. 수정할 수 없습니다. 따라서 final로 선언된 로컬 변수만 사용할 수 있습니다. final이란 전혀 수정할 수 없다는 의미입니다. 이를 final로 선언하지 않으면 메서드 안에서 수정해서는 안 됩니다. 이것이 조건입니다. 다시 한 번 요점을 정리하겠습니다. 람다 표현식은 로컬 변수를 접근하거나 캡처할 수 있습니다. 단, 그 변수가 final이거나 메서드 안에서 전혀 수정되지 않은 경우에만 가능합니다. 이것이 우리가 배운 요점입니다.

이제 다음으로 배울 것은 클래스의 인스턴스 변수로 변수를 선언하는 것입니다. 이는 메서드 외부에 있으며, demo 클래스의 일부입니다. 여기서 temp라는 변수를 선언하고 값은 10으로 할당하겠습니다. 변수를 선언했습니다. 람다 표현식 안에서 이 변수를 접근할 수 있을까요? 확인해보겠습니다. temp, 네, 접근할 수 있습니다.

이것은 클래스의 멤버 또는 인스턴스 변수이기 때문에 초록색으로 표시됩니다.

이것을 수정할 수 있나요?

괄호 안에 ++temp를 작성할 것입니다.

네, 인스턴스 변수에 접근할 수 있고 수정할 수도 있습니다.

그들은 반드시 final 변수일 필요는 없습니다.

어떤 변수들만 final이어야 하나요?

람다 표현식이 정의된 메서드에 로컬인 변수와 클래스에 속한 변수는 수정할 수 있습니다.

그들은 반드시 final일 필요는 없습니다.

그래서 우리는 여기서 세 가지를 배웠습니다.

그것들은 무엇일까요?

람다 표현식은 자체 변수를 가질 수 있으며, 람다 표현식 내부에서 원하는 만큼 사용할 수 있습니다.

두 번째로, 람다 표현식은 이 표현식이 정의된 메서드의 변수를 접근할 수 있지만, 그 변수는 final이거나 사실상 final이어야 합니다.

세 번째로, 람다 표현식은 인스턴스 변수도 캡처할 수 있습니다.

그들이 final이 아니더라도 접근할 수 있으며, 람다 표현식은 이 인스턴스 변수를 수정할 수 있습니다.

아이디어는 람다 표현식이 내부 클래스와 유사하다는 것입니다. 같지는 않지만 내부 클래스와 유사합니다.

내부 클래스는 외부 클래스의 멤버에 접근할 수 있지만, 익명 내부 클래스는 메서드 내부에 선언된 로컬 변수에 접근할 수 없습니다. 그리고 이것은 사실입니다.

따라서 람다 표현식에도 동일하게 적용됩니다.

이것이 메서드의 로컬 멤버를 캡처하는 것과 인스턴스 변수를 캡처하는 것에 대한 전부입니다.

다음으로 보여줄 것은, 람다 표현식을 매개변수로 전달할 수 있는지입니다.

네. 람다 표현식을 메서드의 객체로 전달할 수 있습니다.

람다 표현식은 메서드를 정의하는 데 사용됩니다.

그래서 우리는 메서드를 객체로 보낼 수 있습니다.

이를 설명하기 위해 이것을 제거하고 다른 클래스를 작성하여 보여드리겠습니다.

여기 인터페이스 아래에 하나의 클래스를 작성하겠습니다. UseLambda라고 부르겠습니다. 알겠죠?

그런 다음 이 안에 callLambda라는 메서드를 작성하겠습니다. 알겠죠?

이 메서드는 MyLambda ml이라는 매개변수를 받을 것이고, ml.display를 호출할 것입니다. MyLambda display입니다.

그래서 이 클래스만 보면, 코드가 단 네 줄입니다.

이것은 UseLambda 클래스이며, 이 인터페이스 타입의 매개변수를 받고 그 메서드를 호출하는 callLambda라는 메서드를 가지고 있습니다.

따라서 이 callLambda 메서드를 호출하는 사람이 이 MyLambda로 참조할 수 있는 객체를 보내야 합니다.

그래서 데모 클래스에 가겠습니다.

그 안에 method1이 있습니다.

그래서 이 callLambda 메서드를 호출하겠습니다.

여기 이 메서드 안에서. 여기서 할 것입니다.

우선 UseLambda ul 객체를 생성하고, new UseLambda로 할당합니다.

알겠죠, 객체를 생성하고 있습니다.

그런 다음 이 메서드 UseLambda.callLambda를 호출하겠습니다.

이제 이 타입의 매개변수가 필요합니다.

이 타입의 매개변수가 필요합니다.

그것은 무엇입니까? MyLambda 표현식입니다.

그래서 매개변수를 전달하기 위해, 직접 람다 표현식을 작성하겠습니다.

그리고 이 안에 System.out.println("Hello")을 작성하겠습니다.

그게 다입니다. 그래서 이것이 끝입니다.

보세요, 이 메서드를 호출하고 있습니다, 호출.

이 부분, 제가 강조한 이 부분만 보세요.

그래서 람다 표현식 자체를 전달하고 있습니다.

이 람다 표현식이 이것으로 가고, 이 ml이 이 람다 표현식을 참조하게 됩니다.

그래서 이것이 이것과 결합되면, 지금까지 보여드린 것처럼 MyLambda ml =을 작성하고 람다 표현식을 작성하는 것과 같습니다.

그래서 동일한 일이 발생합니다.

그런 다음 이 메서드가 호출될 것입니다.

그래서 람다 표현식을 매개변수로 또는 객체로 전달할 수 있습니다.

그래서 우리는 메서드를 객체로 전달하고 있다고 말합니다.

이것은 메서드입니다.

여기 display 메서드가 있습니다.

이제 이미 메인 메서드가 준비되어 있으므로, 작동해야 합니다.

메인 메서드가 이 메서드를 호출하고, method1이 이 람다 표현식을 호출합니다.

즉, 람다 표현식을 전달하여 이 callLambda 메서드를 호출합니다.

이것을 실행해 보겠습니다.

그러면 화면에 'Hello'가 표시되어야 합니다.

네, 'Hello'가 표시됩니다. 그게 다입니다.

보세요, 어떤 메서드가 함수형 인터페이스를 매개변수로 받을 때, 그 메서드에 람다 표현식을 전달할 수 있습니다.

이것은 Java에서 가장 일반적으로 사용되는 것입니다.

이 유형의 것이 가장 일반적으로 사용됩니다.

그래서 이 비디오의 모든 내용입니다.

이것을 매우 주의 깊게 관찰하고, 비디오를 본 후에 모든 것을 스스로 시도해 보십시오. 그래서 연습하십시오.

이것은 매우 중요합니다.

나중에 과정의 여러 곳에서 사용됩니다.

여기서 람다 표현식이 유용합니다.

그래서 예제도 보여드렸습니다.

거기서 사용할 수 있습니다.

그래서 이것을 연습하십시오.

이 비디오의 모든 내용입니다.

213. Method Reference

이 비디오에서는 또 다른 흥미로운 주제인 메서드 참조에 대해 배워보겠습니다.

메서드 참조는 함수형 인터페이스를 사용하여 생성되거나 정의됩니다. 만약 인터페이스가 단일 메서드를 가지고 있다면, 그것은 함수형 인터페이스라고 불립니다. 그래서 함수형 인터페이스에 메서드에 대한 참조를 할당할 수 있습니다.

예제를 통해 살펴보겠습니다.

여기 MyLambda라는 인터페이스가 있습니다. 이 인터페이스는 문자열을 매개변수로 받는 하나의 display 메서드를 가지고 있습니다. 이제 MyLambda ml의 참조를 선언하고 이것에 할당하겠습니다. 이 문자열로 무엇을 하고 싶나요? System.out.println을 사용하여 출력하고 싶습니다. 그래서 메서드의 참조를 사용할 수 있습니다.

System.out은 객체입니다, 그렇죠? System은 클래스이고, out은 그 안의 객체입니다, 그리고 println이라는 정적 메서드가 있습니다. 그게 전부입니다.

이제 어떤 일이 벌어지냐면, 이 println이 이 display 메서드에 할당됩니다. 그래서 이 display 메서드는 println 메서드처럼 동작하게 됩니다. 그래서 이것이 println처럼 동작하게 되면, 내가 어떤 문자열을 전달하더라도 출력하게 됩니다. 그렇습니다, 그래서 이 메서드는 println 메서드가 됩니다.

한번 확인해봅시다.

이제 ml.display를 호출할 것입니다. 문자열 "hello"를 전달하면 출력될 것입니다. 확인해봅시다.

이 프로그램을 실행해보세요. 그러면 "hello"가 출력됩니다. 왜 출력되나요? display를 system.out.println으로 만들었기 때문입니다. 그래서 이 println을 범위 해석을 사용하여 작성했습니다. 클래스 이름과 객체 이름을 사용했고, 이것은 정적 메서드이기 때문에 범위 해석을 사용하여 작성했습니다.

여기서 하나 더 정적 메서드를 작성하고 보여드리겠습니다.

이 클래스 Lambda expression 안에 정적 메서드 reverse를 작성했습니다, 철자 오류는 무시하세요. 문자열을 받아 문자열 버퍼 객체를 생성하여 문자열을 뒤집는 정적 메서드 reverse를 작성했습니다. 문자열 버퍼 안에 reverse라는 메서드가 있고, 이것을 사용하여 뒤집습니다. 이 문자열 버퍼를 출력합니다.

이 정적 메서드를 사용하여 ml에 메서드 참조로 할당할 수 있을까요? 네, 그래서 클래스 이름은 Lambda Demo입니다. 그래서 여기에 할당할 것입니다. 보세요, Lambda Demo. 그리고 이것은 C++의 범위 해석과 같습니다, 그렇죠? 참조를 위해 이 범위 해석 연산자를 사용합니다.

그리고 메서드 이름은 reverse입니다. 그게 전부입니다.

여기서 다른 정적 메서드를 할당했습니다. 이전에는 system.out과 그것의 println 메서드를 할당했었죠. 지금은 lambda demo 클래스의 reverse 메서드를 할당했습니다, 그렇죠? 그리고 이제 display를 호출하고 있습니다. 그래서 실제로 display가 무엇이 되었나요? display가 reverse가 되었습니다. 그래서 내가 "hello"를 전달하면 "hello"의 역순을 출력해야 합니다. 네, H E L L O가 역순이 됩니다.

사실 이것은 오류가 되어야 하지만 E R R 오류가 되었습니다. 그래서 다시 실행하면 O L L E H가 출력됩니다. 네, 역순이 되었군요.

한 가지를 주목하셨다면, MyLambda ml을 같은 참조로 사용했습니다. 여기서 한 번은 println을 할당했습니다. 그래서 println 메서드를 호출할 수 있었고, 지금은 reverse를 할당했기 때문에 다른 메서드인 reverse 메서드를 호출하고 있습니다. 그래서 같은 참조를 사용하여 다른 메서드를 호출할 수 있습니다. 이 참조를 사용하여 단일 문자열을 매개변수로 받는 어떤 메서드든 할당할 수 있고, 그 특정 메서드를 호출할 수 있습니다. 그래서 동적으로 어떤 메서드든 할당하고 호출할 수 있습니다. 이것이 메서드 참조의 이점입니다. 어떤 메서드든 할당하고 함수형 인터페이스나 단일 메서드를 가진 인터페이스에 그 메서드를 호출할 수 있습니다.

이제 다음을 봅시다. 만약 그것이 정적이 아니라면, 어떻게 할까요? 정적이 아니라면, 이렇게 할당할 수 없습니다. 그러면 어떻게 해야 할까요? 우선 lambda의 객체를 생성해야 합니다, 알겠죠? Lambda Demo ld를 new Lambda Demo로 할당합니다. 객체를 생성했습니다. 그래서 객체 이름은 ld입니다. 그러면 클래스 이름 대신, 정적 메서드는 클래스 이름을 사용하여 참조할 수 있습니다. 그렇죠, 그래서 클래스 이름을 사용하여 참조했는데, 이제는 ld, 객체 이름인 ld와 그것의 reverse를 사용해야 합니다.

그럼 객체를 사용하여 메서드 참조를 할당할 수 있다는 것입니다.

비정적 멤버의 경우 객체를 가져와서 할당해야 합니다, 맞죠?

이제 같은 일이 일어날 것입니다.

그래서 정적 메서드와 비정적 메서드를 모두 보여드렸습니다.

이제 한 가지 더 보여드리겠습니다.

이 메서드를 제거하겠습니다.

이것을 제거할게요, 괜찮죠?

생성자를 작성하겠습니다.

어떤 클래스의 생성자를 메서드 참조로 할당할 수 있습니까?

네, 할당할 수 있습니다.

먼저 생성자를 정의하겠습니다.

그래서 저는 이 Lambda 데모 클래스에 문자열을 매개변수로 받는 생성자를 작성했습니다

그리고 그것은 문자열을 대문자로 출력할 것입니다, 알겠죠?

이제 함수형 인터페이스의 참조에 이 생성자를 할당하고 싶습니다.

그래서 생성자가 무엇인지요?

어떻게 할당하는지요?

확인해봅시다.

Lambda 데모를 호출하고

그 다음 메서드의 참조를 하세요.

new라고만 말하면 됩니다.

그래서 이 생성자가

이 생성자를 참조하고 있습니다.

그래서 이제 람다 표현식의 display 메서드가 이 생성자를 참조하고 있습니다.

그래서 display를 호출하면

이 생성자가 호출되고

대문자로 출력됩니다.

그래서 이 hello를 대문자로 출력할 것입니다.

hello를 소문자로 만들겠습니다.

이것이 호출되는지 확인해봅시다.

네, 호출되었습니다.

그래서 클래스의 생성자도 메서드의 참조로 할당할 수 있습니다.

여기서 생성자의 참조가 주어졌습니다.

그래서 정적 메서드를 보여드렸고,

비정적 인스턴스 메서드를 보여드렸고,

그리고 하나 더, 생성자입니다.

생성자의 경우 클래스 이름과 함께 new라고 말하면 됩니다.

이제 이것에 대해 더 알아봅시다.

매개변수가 여러 개 있는 경우

여기서 하나의 메서드를 작성하겠습니다.

하나의 문자열을 가져오고

하나의 문자열을 더 매개변수로 받겠습니다, 알겠죠,

str 두 번째, 알겠죠, 첫 번째는 str 하나이고

두 번째는 str 두 번째입니다.

두 개의 문자열을 가져봅시다.

이제 여기서 문자열 클래스를 하나 할당하고

메서드는 compare to입니다.

compare to는 하나의 매개변수만 필요하고

다른 하나는 객체 자체입니다.

그래서 실제로 str1.compare to str2를 호출할 것입니다.

하나의 매개변수만 가져가지만

첫 번째 객체는 참조로 사용할 것입니다.

그래서 내부적으로는

이렇게 호출될 것입니다 str1.compare to str2.

그래서 여기서 두 개의 문자열을 전달해야 합니다.

hello와 비교하여, 알겠죠,

결과는 0이거나 -1이거나 1이어야 합니다.

이미 compare to 메서드에 대해 알고 있습니다.

그래서 이것을 출력하겠습니다.

오, 오류가 발생했습니다.

네, 한 가지 사실은

이 compare to 메서드는 정수를 반환합니다.

이제 완벽합니다

왜냐하면 0이거나 -1이거나 1이어야 하기 때문입니다.

이것을 실행해봅시다.

그래서 결과가 0이어야 합니다

왜냐하면 둘 다 동일하기 때문입니다.

네, 동일합니다.

그래서 0을 반환합니다.

다른 문자열로 변경하겠습니다.

Well, 알겠죠, 그래서 이 O를 제거하겠습니다.

그래서 H와 W, H는 더 작고, W는 더 큽니다.

그래서 -1을 반환해야 합니다.

그래서 ASCII 코드의 차이로 -15를 주었습니다.

그래서 결과는 음수입니다, 알겠죠.

이제 H 대신 Z로 만들겠습니다.

그래서 이제 양수 결과를 줄 것입니다

왜냐하면 Z는 W 다음에 오기 때문입니다.

네, 양수 결과를 주고 있습니다

그리고 차이는 ASCII 코드에서 3입니다.

그래서 답은 3입니다.

이것이 메서드 참조에 관한 것입니다.

함수형 인터페이스 참조를 가져와서

직접 메서드를 할당할 수 있습니다.

정적 메서드나 비정적 메서드

그리고 생성자도 가능합니다.

그리고 매개변수가 여러 개인 것도 가능합니다.

여기서 할당한 메서드는

display로 변환될 것입니다.

그래서 display를 호출하면 내부적으로

이 메서드가 호출됩니다.

그래서 이 비디오에서는 여기까지입니다.

이것을 연습해보세요.

유용하고 편리합니다.

작고 간결한 코드를 작성하는 데 유용합니다.

이것의 장점은 간결한 코드를 작성할 수 있다는 것입니다.

네, 한 가지 더 말씀드려야 할 것은

이것은 마치 제가

다른 메서드를 동일한 참조에 할당하고 호출하는 것을 보여드렸습니다.

그래서 이것은 다형성(polymorphism)과 비슷합니다.

네, 부모 클래스 참조를 가지고

자식 클래스 객체를 가지고

재정의된 메서드를 호출하는 것입니다.

그래서 객체의 메서드가 호출될 것입니다

이것은 그것과 비슷합니다.

그래서 간접적으로 우리는 다형성을 달성하고 있습니다

많은 코드를 작성하지 않고,

많은 클래스를 작성할 필요도 없습니다.

몇 줄의 코드로

다형성 같은 메커니즘을 달성하고 있습니다.

그래서 여기까지입니다.

이것을 연습해보세요.

